"""Code-generator style API for snippet implementors.

Public functions:
- get_snippet(name) -> str | None
- register_generator(fn, keys?)
"""

from __future__ import annotations

from typing import Optional

from .aliases import NAME_ALIASES
from .catalog import CatalogEntry, find_catalog_entry
from .generators import BUILTINS, Generator

# Mutable registry layering custom generators over built-ins
_GENERATORS: dict[str, list[Generator]] = {k: [v] for k, v in BUILTINS.items()}


def register_generator(fn: Generator, keys: list[str] | None = None) -> None:
    """Register a generator for one or more canonical keys.

    If no keys are provided, the generator is appended globally and called as a
    fallback for any unknown key (rare). Prefer specifying keys.
    """
    if keys is None:
        # Register under a special fallback key
        _GENERATORS.setdefault("*", []).append(fn)
        return
    for k in keys:
        _GENERATORS.setdefault(k, []).append(fn)


def _run_generators(key: str, name: str) -> str | None:
    gens = _GENERATORS.get(key, []) + _GENERATORS.get("*", [])
    entry: Optional[CatalogEntry] = find_catalog_entry(name) or None
    for gen in gens:
        try:
            code = gen(name, entry)
            if code:
                return code.strip()
        except Exception:
            # best-effort; ignore generator failures
            continue
    return None


def get_snippet(name: str) -> str | None:
    """Return scaffold code for the provided name.

    Resolution order:
    1) Normalize via aliases -> canonical key
    2) Try registered generators for that key (built-ins first)
    3) If a catalog entry exists and no generator produced code, craft a tiny
       docstring-based scaffold for patterns vs. architectures.
    4) Final fallback: generic class scaffold using the provided name.
    """
    key_raw = (name or "").strip().lower()
    key = NAME_ALIASES.get(key_raw, key_raw)

    # 2) Generators
    code = _run_generators(key, name)
    if code:
        return code

    # 3) Catalog-enriched minimal scaffold
    entry = find_catalog_entry(key)
    if entry:
        pname = str(entry.get("name", name))
        desc = str(
            entry.get("intent")
            or entry.get("description")
            or "Scaffold generated by mcp-architecton."
        )
        category = str(entry.get("category", "Pattern"))
        ident = pname.title().replace(" ", "")
        if category.lower().startswith("arch"):
            return (
                (
                    "class {ident}Helper:\n"
                    '    """{desc}\n\n'
                    "    This is a minimal helper scaffold for {pname}.\n"
                    '    """\n\n'
                    "    def __init__(self) -> None:\n"
                    "        pass\n\n"
                    "    def apply(self):  # pragma: no cover - scaffold\n"
                    "        # TODO: wire ports/adapters or layers as appropriate\n"
                    "        pass\n"
                )
                .format(ident=ident, desc=desc, pname=pname)
                .strip()
            )
        return (
            (
                "class {ident}:\n"
                '    """{desc}"""\n\n'
                "    def __init__(self) -> None:  # pragma: no cover - scaffold\n"
                "        pass\n"
            )
            .format(ident=ident, desc=desc)
            .strip()
        )

    # 4) Final fallback
    ident = (name or "Item").title().replace(" ", "")
    return (
        (
            "class {ident}:\n"
            '    """Scaffold for {name}. Add real behavior here."""\n\n'
            "    def __init__(self) -> None:  # pragma: no cover - scaffold\n"
            "        pass\n"
        )
        .format(ident=ident, name=name)
        .strip()
    )


__all__ = ["get_snippet", "register_generator"]
